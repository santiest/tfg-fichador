\chapter{Code Implementation and Development Challenges}
\label{cap:codeAndChallenges}

The software development phase represents a significant portion of the project timeline, demanding 
meticulous attention to detail and thorough problem-solving skills. In the forthcoming sections, 
an overview of the software requirements will be provided, shedding light on how these 
requirements were effectively addressed. Additionally, detailed insights into the encountered 
challenges and the corresponding solutions devised will be explored.

One crucial decision made early on was the selection of CircuitPython as the programming language 
for the device. This decision stemmed from several key factors, including its open-source nature, 
extensive library support, and the availability of pre-existing libraries with MIT licenses, 
particularly those essential for handling NFC readers. Furthermore, CircuitPython's user-friendly 
syntax and simplified microcontroller programming paradigm were deemed advantageous compared to 
alternatives like MicroPython, contributing to smoother development workflows.

However, it's important to note that despite the benefits of CircuitPython, the project encountered 
limitations imposed by the microcontroller's memory capacity, capped at 256kB. This constraint was 
exacerbated by the use of Python, a high-level language known for its memory-intensive nature. 
Throughout the development process, various memory optimization strategies were implemented to 
mitigate these limitations. These optimizations will be thoroughly explained, providing valuable 
insights into managing resource constraints in microcontroller-based projects.

In addition to the aforementioned aspects, it's crucial to highlight the iterative nature of 
software development, where frequent testing, debugging, and refinement cycles were integral to 
achieving desired functionality and performance. This iterative approach enabled the project team 
to address emerging issues promptly and iteratively enhance the software's robustness and 
reliability.

Furthermore, a detailed examination of the software architecture and design decisions made will 
offer valuable insights into the project's development methodology and the rationale behind 
specific implementation choices.

\section{CircuitPython: Advantages and Disadvantages}

CircuitPython is an open-source programming language designed specifically for 
microcontroller-based development. Developed primarily by Adafruit Industries, CircuitPython is 
built on top of the Python programming language, offering a simplified yet powerful platform for 
programming microcontrollers. Unlike traditional embedded programming languages, CircuitPython 
abstracts many low-level complexities, making it more accessible to beginners and hobbyists while 
still providing advanced features for experienced developers.

\begin{figure}[h]
	\centering
	\includegraphics[width = .5\textwidth]{Imagenes/Vectorial/circuitpython_logo.pdf}
	\caption{CircuitPython's logo}
	\label{fig:circuitpython_logo}
\end{figure}

One of the key advantages of CircuitPython is its user-friendly syntax and high-level abstractions, 
which resemble those of Python, a language renowned for its readability and simplicity. This makes 
CircuitPython particularly attractive to beginners and educators, enabling them to quickly grasp 
programming concepts and develop projects without being bogged down by intricate syntax or complex 
setup procedures.

Furthermore, CircuitPython simplifies the process of interacting with hardware peripherals and 
sensors commonly used in embedded systems. It provides a consistent and intuitive API (Application 
Programming Interface) for accessing GPIO pins, I2C and SPI interfaces, analog inputs, and other 
hardware features, streamlining the development process and reducing the learning curve associated 
with embedded programming.

Another notable advantage of CircuitPython is its extensive library support, particularly for 
popular microcontroller boards and peripherals. Adafruit maintains a vast repository of 
CircuitPython libraries, covering a wide range of sensors, displays, actuators, communication 
modules, and other components commonly used in electronics projects\footnote{Adafruit's Library 
Bundle: \url{https://github.com/adafruit/Adafruit_CircuitPython_Bundle}}. These libraries abstract 
the complexities of interfacing with specific hardware, allowing developers to focus on application 
logic rather than low-level hardware details.

Despite its numerous advantages, CircuitPython does have some limitations and drawbacks. One 
notable limitation is its higher memory footprint compared to lower-level languages like C or 
assembly, which can be a concern for projects with strict memory constraints. Additionally, while 
CircuitPython abstracts many hardware complexities, it may sacrifice some performance compared to 
bare-metal or lower-level programming approaches.

Overall, CircuitPython offers a compelling combination of simplicity, accessibility, and 
versatility for microcontroller-based development, making it an excellent choice for a wide range 
of projects, from educational endeavors to commercial products. Its rich ecosystem of libraries, 
ease of use, and strong community support contribute to its popularity among hobbyists, educators, 
and professional developers alike\cite{circuitpython_docs}.

For this project, CircuitPython version 9.0.0 will be used.

\section{Code Requirements}

The device must prioritize responsiveness and intuitive usability for all employees. This ensures 
that the device can be easily operated by users of varying technical proficiency levels, promoting 
efficient and accurate clocking processes.

Furthermore, the device must maintain the highest possible uptime to ensure continuous operation 
without interruptions. This is crucial for accurate time tracking and prevents any disruptions that 
could lead to discrepancies in employee attendance records.

Data integrity is of paramount importance, as any loss of data could result in unfair deductions 
from employees' wages. Therefore, the device must be designed to prevent data loss under any 
circumstances, even in the event of power outages or connectivity issues. It should have the 
capability to store clockings locally and reliably transmit them to the server once connectivity is 
restored.

In situations where internet connectivity is temporarily lost, the device must continue to store 
clockings and transmit them as soon as connectivity is regained. This ensures that no clocking data 
is lost and enables seamless operation regardless of network conditions.

Efficient data transmission is essential for real-time monitoring and analysis of employee 
attendance. Therefore, the device should send clocking data as soon as it is available, without any 
delays, to ensure timely reporting and accurate statistics.

Flexibility is also key, as the device must be capable of operating using either WiFi or cellular 
data connectivity, depending on the specific configuration and deployment requirements.

Moreover, the device should incorporate a mode-switching feature, allowing it to display relevant 
information such as the device's ID and enabling easy implementation of additional modes in the 
future. This ensures scalability and adaptability to changing needs and requirements.

Additionally, the device must display the current time on the screen to provide users with 
real-time information and facilitate accurate clocking processes.

To enhance user experience and ensure successful clocking operations, the device should provide 
visual and audible cues to indicate successful clockings. It should also alert users to errors, 
such as attempting to clock in multiple times with the same keycard.

Finally, all clocking data should be securely transmitted to an API using POST requests, ensuring 
that it is reliably delivered to the server for processing and storage. This maintains data 
integrity and enables seamless integration with existing systems and workflows.


\section{Code Implementation}

\subsection{Asynchronous Programming}

Asynchronous programming is a programming paradigm that allows multiple tasks to be executed 
concurrently, without the need for explicit parallelism or multithreading. It enables programs to 
perform non-blocking operations, where tasks can be started and completed independently of each 
other, leading to improved performance and responsiveness.

In CircuitPython, asynchronous programming is achieved using the \texttt{asyncio} module, which 
provides a framework for writing asynchronous code using coroutines. Coroutines are functions 
that can be paused and resumed during execution, allowing for efficient task scheduling and 
coordination.

The key concept in asynchronous programming in Python is the \texttt{async} and \texttt{await} 
keywords. Functions defined with the \texttt{async} keyword are called asynchronous functions, and 
they can be paused with the \texttt{await} keyword when they encounter an operation that may block, 
such as I/O operations or network requests.

When an asynchronous function is awaited, it returns control to the event loop, allowing other 
tasks to continue executing in the meantime. Once the awaited operation completes, the function 
resumes execution from the point where it was paused.

The event loop is a central component of asynchronous programming in Python and CircuitPython. It 
manages the execution of asynchronous tasks and ensures that they are scheduled and executed 
efficiently. The event loop continuously checks for tasks that are ready to run, executes them 
until completion or until they are paused, and then moves on to the next task 
\cite{circuitpython_docs}.

The code extensively utilizes asynchronous programming to enhance the perception of concurrency 
and prevent the device from becoming unresponsive. This is crucial, especially considering that the 
device displays the time, including seconds, on the screen. However, while this approach offers 
significant benefits, it also introduces certain drawbacks, which will be addressed later.

Later on, this aspect will be further explored. Essentially, two tasks will run within the event 
loop: one managing the main loop, waiting for workers to approach the device with their keycards, 
while the other will handle the transmission of clockings to the internet.

\subsection{Main Loop and Operating Modes}



\subsection{Interchangeable WiFi and Cellular Data Operation}

\subsection{SIM7020E Module}

\section{Challenges}

\subsection{Lack of Multithreading}

\subsection{Memory Constraints and SSL Certificates}

\subsection{NFC Reader Unresponsiveness}

\subsection{Storage}
